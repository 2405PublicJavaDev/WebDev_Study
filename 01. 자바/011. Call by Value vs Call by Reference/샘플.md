# Call by Value vs Call by Reference

**메소드 호출할 때 파라미터를 전달하는 방법**

## Call by Value

- 함수의 인자를 전달할 때 값만 전달하는 방식
- 메소드 호출할 때 값을 넘겨줌
- Pass by Value라고 부르기도 함
- 메소드를 호출하는 호출자(Caller)의 변수와 호출 당하는 수신자(Callee)의 파라미터는 복사된 서로 다른 변수
- 값만 전달하기 때문에 수신자의 파라미터를 수정해도 호출자의 변수에는 영향을 끼치지 않음
- 메모리를 절약할 수 있으며 속도가 빨라짐 -> 임베디드 환경에서는 C 포인터를 이용해 코딩
- 예 : C언어
    - 포인터 변수를 파라미터 받게 하고 함수를 호출할 때 주소 연산자를 이용해 주소값을 직접 념겨 직접적인 메모리 참조가 가능

<br/>

> 값을 넘겨받은 메소드에서 값을 복사하여 새로운 지역 변수에 저장함 <br/>
즉 값을 넘겨받은 두 번째 메소드는 첫 번째 메소드의 변수를 사용하는 것이 아니라 자신이 새롭게 생성한 지역 변수에 첫 번째 메소드의 변수 이름과 변수 값을 복사하여 사용하는 것 <br/>
이 때문에 두 번째 메소드에서 값을 바꿔도 첫 번째 메소드에는 영향을 끼칠 수 없는 것 <br/>

<br/>

## Call by Reference

- 주소를 전달하는 방식
- 참조(주소)를 직접 전달
- Pass by Referecne라고 부르기도 함
- 참조를 직접 넘기기 때문에 호출자의 변수와 수신자의 파라미터는 완전히 동일한 변수
- 메서드 내에서 파라미터를 수정하면 그대로 원본 변수에도 반영됨

<br/>

> 호출자의 변수와 수신자의 변수는 같은 주소를 공유하는 변수임 <br/>
참조 타입은 Heap 메모리 영역에 생성된 객체의 주소값을 참조하기 때문에 참조 타입이라고 불림 <br/>
따라서 첫 번째 메소드에서 두 번째 메소드로 넘겨준 것은 변수의 주소값이며, 첫 번째 메소드의 주소값과 동일한 주소값을 가지고 두 번째 메소드의 객체 상태를 수정하면 서로 동일한 주소를 참조하기 때문에 영향을 끼치게 됨

<br/>

### 자바의 파라미터 전달 방법

- Call by Value로만 동작함
- 자바에는 Call by Reference라는 것이 존재하지 않음
- 포인터를 철저하게 숨겨 개발자가 직접 메모리 주소를 관리하지 못하게 조치했기 때문 <-> C언어는 포인터를 통해 그대로 주소로 메모리를 참조할 수 있음
- 원시값이 복사되냐 / 주소값이 복사되냐 의 차이
- 매개변수에 복사된 값에 따라 원시값이면 바로 연산을 하고 주소값이면 메모리 주소를 참조해 값을 가져와 연산함


<br/>
<br/>
<br/>
<br/>

#### 참고 자료

- https://bcp0109.tistory.com/360
- https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference
- https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9E%90%EB%B0%94%EB%8A%94-Call-by-reference-%EA%B0%9C%EB%85%90%EC%9D%B4-%EC%97%86%EB%8B%A4-%E2%9D%93