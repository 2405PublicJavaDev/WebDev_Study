# 멸종위기의 대장균 찾기
## 문서 관리자
조승효(문서 생성자)
## 문제 풀이
재귀 쿼리라는 것을 이용해야 한다.

MySQL 같은 경우 재귀쿼리 구조가 다음과 같다

WITH RECURSIVE (메모리 상에 저장될 가상 테이블 명) AS (
    -- Non-Recursive 문장(첫번째 루프에서만 실행됨)
    UNION ALL
    -- Recursive 문장(읽어 올때마다 행의 위치가 기억되어 다음번 읽어 올 때 다음 행으로 이동함)
);

SELECT * FROM (메모리 상에 저장될 가상 테이블명);

Oracle 같은 경우 재귀쿼리는 CONNECT BY 를 써서 나타낸다
## 정답 쿼리(MySQL)
``` sql
-- 코드를 작성해주세요
WITH RECURSIVE CTE AS(
    SELECT ID, PARENT_ID, 1 AS GENERATION
    FROM ECOLI_DATA
    WHERE PARENT_ID IS NULL
    UNION ALL
    SELECT E.ID, E.PARENT_ID, GENERATION + 1
    FROM ECOLI_DATA E
    INNER JOIN CTE ON E.PARENT_ID = CTE.ID 
)
SELECT COUNT(ID) "COUNT", GENERATION
FROM CTE C
WHERE NOT EXISTS (
    SELECT 1
    FROM CTE
    WHERE PARENT_ID = C.ID
)
GROUP BY GENERATION
ORDER BY GENERATION ASC;
```
## 비교 쿼리1(Oracle)
``` sql
WITH CTE (ID, PARENT_ID, GENERATION) AS (
    SELECT ID, PARENT_ID, 1 AS GENERATION
    FROM ECOLI_DATA
    WHERE PARENT_ID IS NULL
    UNION ALL
    SELECT E.ID, E.PARENT_ID, C.GENERATION + 1
    FROM ECOLI_DATA E
    JOIN CTE C ON E.PARENT_ID = C.ID
)
SELECT COUNT(ID) AS "COUNT", GENERATION
FROM CTE C
WHERE NOT EXISTS (
    SELECT 1
    FROM ECOLI_DATA E
    WHERE E.PARENT_ID = C.ID
)
GROUP BY GENERATION
ORDER BY GENERATION ASC;
```
## 비교 쿼리2(Oracle)
``` sql
SELECT COUNT(ID), GENERATION 
FROM (
    SELECT ID, LEVEL AS GENERATION
    FROM ECOLI_DATA
    CONNECT BY PRIOR ID = PARENT_ID
    START WITH PARENT_ID IS NULL
) C
WHERE NOT EXISTS (
    SELECT 1
    FROM ECOLI_DATA E
    WHERE E.PARENT_ID = C.ID
)
GROUP BY GENERATION
ORDER BY GENERATION ASC;
```
## 문제 링크
https://school.programmers.co.kr/learn/courses/30/lessons/301651